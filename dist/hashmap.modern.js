function t(t,e=0,s=0){const i=1&(s=s&&s>0?Math.min(s,t.length):t.length),r=s-i;let h=e|=0,n=0,o=0;for(;o<r;)n=65535&t.charCodeAt(o++)|(65535&t.charCodeAt(o++))<<16,n*=3432918353*n|0,n=n<<15|n>>>17,n*=461845907,h^=n,h=h<<13|h>>>19,h=5*h+3864292196;return i&&(n^=65535&t.charCodeAt(o),n*=3432918353,n=n<<15|n>>>17,n*=461845907,h^=n),h^=s,h^=h>>>16,h*=2246822507,h^=h>>>13,h*=3266489909,h^=h>>>16,0|h}const e=function(t){return!!(t&&t.constructor&&t.call&&t.apply)},s=function(t,e){return t===e},i=function t(e,s,i=-1){return 0===i||Array.isArray(e)&&Array.isArray(s)?e.length===s.length&&e.every((e,r)=>t(e,s[r],--i)):e===s},r=function e(i){switch(typeof i){case"boolean":return{equalTo:s,hash:i?0:1};case"number":return Number.isNaN(i)?{equalTo:function(t,e){return Number.isNaN(e)},hash:0}:Number.isFinite(i)?Number.isInteger(i)?{equalTo:s,hash:i}:{equalTo:s,hash:t(i.toString())}:{equalTo:s,hash:0};case"string":return{equalTo:s,hash:t(i)};case"undefined":return{equalTo:s,hash:0};default:if(!i)return{equalTo:s,hash:0};if(i instanceof RegExp)return{equalTo:function(t,e){return e instanceof RegExp&&t+""==e+""},hash:t(i+"")};if(i instanceof Date)return{equalTo:function(t,e){return e instanceof Date&&t.getTime()===e.getTime()},hash:0|i.getTime()};if(i instanceof Array){let t=[],s=i.length;for(let r=0;r<i.length;r++){const h=e(i[r]);t.push(h.equalTo),s+=31*h.hash}return Object.freeze(t),{equalTo:function(e,s){if(s instanceof Array&&e.length===s.length){for(let i=0;i<e.length;i++)if(!t[i](e[i],s[i]))return!1;return!0}return!1},hash:0|s}}return i.hasOwnProperty("_hmuid_")||(i._hmuid_=++u.uid),e(i._hmuid_)}};class h{get size(){let t=0;for(const e of this)t++;return t}static from(t){return t instanceof h?t:new m(t)}filter(t=(()=>!0),e=this){return new g(this,t,e)}forEach(t=(()=>{}),e=this){for(const[s,i]of this)t.call(e,i,s,this);return this}collect(t=[]){if(Array.isArray(t))return t.length?t.concat(Array.from(this)):Array.from(this);if(e(t.set))for(const[e,s]of this)t.set(e,s);else if(e(t.add))for(const e of this)t.add(e);else for(const[e,s]of this)t[e]=s;return t}every(t=(()=>!0),e=this){for(const[s,i]of this)if(!t.call(e,i,s,this))return!1;return!0}some(t=(()=>!0),e=this){for(const[s,i]of this)if(t.call(e,i,s,this))return!0;return!1}find(t=(()=>!0),e=this){for(const[s,i]of this)if(t.call(e,i,s,this))return i}findIndex(t=((t,e)=>e),e=this){for(const[s,i]of this)if(t.call(e,i,s,this))return s}indexOf(t,e=-1){if(Array.isArray(t)){for(const[s,r]of this)if(i(t,r,e))return s}else for(const[e,i]of this)if(s(t,i))return e}has(t){const e=r(t).equalTo;return this.some((s,i)=>e(i,t))}get(t){const e=r(t).equalTo;return this.find((s,i)=>e(t,i))}optionalGet(t){const e=r(t).equalTo;let s=!1;const i=this.find((i,r)=>!!e(t,r)&&(s=!0,!0));return s?o.of(i):o.none()}reduce(t=((t,e)=>e),e,s=this){let i=e;for(const[e,r]of this)i=t.call(s,i,r,e,this);return i}mapKeys(t=((t,e)=>e),e=this){return new x(this,t,e)}mapValues(t=(t=>t),e=this){return new k(this,t,e)}mapEntries(t=((t,e)=>[e,t]),s=this){if(Array.isArray(t)){if(1===t.length&&e(t[0]))return this.mapKeys(t[0],s);if(t.length>1){if(e(t[0]))return e(t[1])?new w(this,(e,i,r)=>[t[0].call(s,e,i,r),t[1].call(s,e,i,r)],this):this.mapKeys(t[0],s);if(e(t[1]))return this.mapValues(t[1],s)}}else if(e(t))return new w(this,t,s);throw new TypeError("MapIterable.mapEntries expects a function or an array of functions")}map(t=((t,e)=>[e,t]),s=this){if(Array.isArray(t))return this.mapEntries(t,s);if(e(t))return new E(this,t,s);throw new TypeError("MapIterable.map expects a function or an array of functions")}concat(t){return t?t instanceof h||t instanceof Map?this.concatMap(t):new A(this,n.from(t)):this}concatMap(t){return t?new v(this,h.from(t)):this}keys(){return new E(this,(t,e)=>e,this)}values(){return new E(this,t=>t,this)}entries(){return this}}class n{get size(){let t=0;for(const e of this)t++;return t}static from(t){return t instanceof n?t:new b(t)}filter(t=(()=>!0),e=this){return new G(this,t,e)}forEach(t=(()=>{}),e=this){for(const s of this)t.call(e,s,s,this)}collect(t=[]){if(Array.isArray(t))return t.length?t.concat(Array.from(this)):Array.from(this);if(e(t.add))for(const e of this)t.add(e);else if(e(t.set))for(const e of this)t.set(e);return t}reduce(t=((t,e)=>e),e,s=this){let i=e;for(const e of this)i=t.call(s,i,e,e,this);return i}every(t=(()=>!0),e=this){for(const s of this)if(!t.call(e,s,s,this))return!1;return!0}some(t=(()=>!0),e=this){for(const s of this)if(t.call(e,s,this))return!0;return!1}has(t,e=-1){return Array.isArray(t)?this.some(s=>i(s,t,e)):this.some(e=>s(e,t))}find(t=(()=>!0),e=this){for(const s of this)if(t.call(e,s,s,this))return s}map(t=(t=>t),e=this){return new T(this,t,e)}concat(t=[]){return new A(this,n.from(t))}values(){return this}keys(){return this}entries(){return h.from(this.map(t=>[t,t]))}}class o{constructor(t,e){this.has=t,this.value=e}static of(t){return new o(!0,t)}static none(){return new o(!1,void 0)}}class a{constructor(t,e){this.key=t,this.value=e}overwrite(t){t.value=this.value}delete(){}}class l extends a{constructor(t,e){super(t,e),this.previous=void 0,this.next=void 0}overwrite(t){t.value=this.value,this.deleted=!0}delete(){this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous),this.deleted=!0}}class u extends h{constructor(t={copy:void 0,depth:void 0,widthAs2sExponent:6}){super();let{depth:e,widthAs2sExponent:s,copy:i}=t;s=Math.max(1,Math.min(16,s));const r=(32/s>>0)-1;e=Math.max(0,Math.min(e&&e>0?e-1:r,r));const h=1<<s;this.options=Object.freeze({widthAs2sExponent:s,width:h,mask:h-1,depth:e}),this.clear(),(t.forEach||i&&i.forEach)&&this.copy(t.forEach?t:i)}get size(){return this.length}has(t){if(this.buckets){const e=r(t);return this.buckets.has(t,e.equalTo,e.hash)}return!1}get(t){if(this.buckets){const e=r(t);return this.buckets.get(t,e.equalTo,e.hash)}}optionalGet(t){if(this.buckets){const e=r(t);return this.buckets.optionalGet(t,e.equalTo,e.hash)}return o.none()}set(t,e){return this.addEntry(new a(t,e)),this}addEntry(t){const e=r(t.key);return this.buckets?(this.buckets=this.buckets.set(t,e.equalTo,e.hash),this.length=this.buckets.length):(this.buckets=new d(t,e.hash,Object.assign({},this.options),this.options.depth),this.length=1),t}copy(t){const s=this;if((i=t)&&e(i[Symbol.iterator])){for(const[e,i]of t)s.set(e,i);return this}if(e(t.entries)){for(const[e,i]of t.entries())s.set(e,i);return this}if(e(t.forEach))return t.forEach(function(t,e){s.set(e,t)}),this;var i;throw new TypeError("HashMap.copy expects an object which is iterable or has a forEach function on it")}clone(){return new u({copy:this,depth:this.options.depth,widthAs2sExponent:this.options.widthAs2sExponent})}delete(t){if(this.buckets){const e=r(t);this.buckets=this.buckets.delete(t,e.equalTo,e.hash),this.length=this.buckets?this.buckets.length:0}return this}clear(){return this.buckets=void 0,this.length=0,this}*[Symbol.iterator](){if(this.buckets)for(const t of this.buckets)yield t}}u.uid=0;class c extends u{constructor(t={copy:void 0,depth:void 0,widthAs2sExponent:6}){super(t),this.start=void 0,this.end=void 0}set(t,e){const s=this.addEntry(new l(t,e));return this.end?s.deleted||(this.end.next=s,s.previous=this.end,this.end=s):this.end=this.start=s,this}delete(t){return super.delete(t),this.start&&this.start.deleted&&(this.start=this.start.next),this.end&&this.end.deleted&&(this.end=this.end.previous),this}clone(){return new c({copy:this,depth:this.options.depth,widthAs2sExponent:this.options.widthAs2sExponent})}*[Symbol.iterator](){let t=this.start;for(;t;)yield[t.key,t.value],t=t.next}}class f{constructor(t){this.entry=t,this.length=1}get key(){return this.entry.key}get value(){return this.entry.value}get(t,e){if(e(t,this.key))return this.entry.value}optionalGet(t,e){return e(t,this.key)?o.of(this.entry.value):o.none()}set(t,e){return e(t.key,this.key)?(t.overwrite(this.entry),this):new p(t,this)}has(t,e){return e(t,this.key)}delete(t,e){if(!e(t,this.key))return this;this.entry.delete()}forEach(t,e){return t.call(e,this.value,this.key),this}*[Symbol.iterator](){0!==this.length&&(yield[this.key,this.value])}}class p extends f{constructor(t,e){super(t),this.next=e,this.length=e.length+1}get(t,e){let s=this;do{if(e(t,s.key))return s.value;s=s.next}while(s)}optionalGet(t,e){let s=this;do{if(e(t,s.key))return o.of(s.value);s=s.next}while(s);return o.none()}set(t,e){let s=this;for(;s;){if(e(t.key,s.key))return t.overwrite(this.entry),this;s=s.next}return new p(t,this)}has(t,e){let s=this;do{if(e(t,s.key))return!0;s=s.next}while(s);return!1}delete(t,e){if(e(t,this.key))return this.entry.delete(),this.next&&(this.next.length=this.length-1),this.next;let s=this.next,i=this;for(;s;){if(e(t,s.key)){s.entry.delete();const t=s.next;return t?(s.entry=t.entry,s.next=t.next):i.next=void 0,this.length--,this}i=s,s=s.next}return this}*[Symbol.iterator](){let t=this;for(;t;)yield[t.key,t.value],t=t.next}}class d extends f{constructor(t,e,s,i){super(t),this.hash=e,this.options=s,this.depth=i}set(t,e,s){if(s===this.hash&&e(t.key,this.key))return t.overwrite(this.entry),this;const i=new y(this.options,this.depth);return i.set(this.entry,()=>!1,this.hash),i.set(t,()=>!1,s),i}get(t,e,s){if(s===this.hash&&e(t,this.key))return this.value}optionalGet(t,e,s){return s===this.hash&&e(t,this.key)?o.of(this.value):o.none()}has(t,e,s){return s===this.hash&&e(t,this.key)}delete(t,e,s){if(s!==this.hash||!e(t,this.key))return this;this.entry.delete()}}class y{constructor(t,e){this.options=t,this.length=0,this.depth=e,this.buckets=new Array(this.options.width)}get(t,e,s){const i=this.buckets[s&this.options.mask];if(i)return i.get(t,e,s>>>this.options.widthAs2sExponent)}optionalGet(t,e,s){const i=this.buckets[s&this.options.mask];return i?i.optionalGet(t,e,s>>>this.options.widthAs2sExponent):o.none()}set(t,e,s){const i=s&this.options.mask;let r=this.buckets[i];if(r){const h=r.length;this.buckets[i]=r.set(t,e,s>>>this.options.widthAs2sExponent),this.buckets[i].length!==h&&this.length++}else this.depth?(this.buckets[i]=new d(t,s>>>this.options.widthAs2sExponent,this.options,this.depth-1),this.length++):(this.buckets[i]=new f(t),this.length++);return this}has(t,e,s){const i=this.buckets[s&this.options.mask];return!!i&&i.has(t,e,s>>>this.options.widthAs2sExponent)}delete(t,e,s){const i=s&this.options.mask;let r=this.buckets[i];return r&&(r=r.delete(t,e,s>>>this.options.widthAs2sExponent),r&&0!==r.length||(this.buckets[i]=void 0,this.length--)),this}*[Symbol.iterator](){for(const t of this.buckets)if(t)for(const e of t)yield e}}class b extends n{constructor(t,e){super(),this.iterable=t,this.ctx=e}get size(){return this.iterable.length?this.iterable.length:this.iterable.size}has(t,e){return this.iterable instanceof Set||this.iterable instanceof n?this.iterable.has(t,e):super.has(t,e)}*[Symbol.iterator](){yield*this.iterable}}class m extends h{constructor(t,e){super(),this.iterable=t,this.ctx=e}get size(){return this.iterable.length?this.iterable.length:this.iterable.size}*[Symbol.iterator](){yield*this.iterable}has(t){return e(this.iterable.optionalGet)?this.iterable.optionalGet(t).has:e(this.iterable.has)?this.iterable.has(t):super.has(t)}optionalGet(t){return e(this.iterable.optionalGet)?this.iterable.optionalGet(t):e(this.iterable.has)?this.iterable.has(t)?(e(this.iterable.get)&&o.of(this.iterable.get(t)),o.of(super.get(t))):o.none():super.optionalGet(t)}get(t){return e(this.iterable.optionalGet)?this.iterable.optionalGet(t).value:e(this.iterable.get)?this.iterable.get(t):super.get(t)}}class g extends m{constructor(t,e,s){super(t,s),this.filterPredicate=e}get size(){let t=0;for(const e of this)t++;return t}*[Symbol.iterator](){for(let[t,e]of this.iterable)this.filterPredicate.call(this.ctx,e,t,this)&&(yield[t,e])}optionalGet(t){const e=super.optionalGet(t);return e.has&&!this.filterPredicate.call(this.ctx,e.value,t,this)?o.none():e}has(t){return this.optionalGet(t).has}get(t){return this.optionalGet(t).value}}class x extends m{constructor(t,e,s){super(t,s),this.mapFunction=e}*[Symbol.iterator](){for(let[t,e]of this.iterable)yield[this.mapFunction.call(this.ctx,e,t,this),e]}}class k extends m{constructor(t,e,s){super(t,s),this.mapFunction=e}*[Symbol.iterator](){for(let[t,e]of this.iterable)yield[t,this.mapFunction.call(this.ctx,e,t,this)]}optionalGet(t){const e=super.optionalGet(t);return e.has?o.of(this.mapFunction.call(this.ctx,e.value,t,this)):e}}class w extends m{constructor(t,e,s){super(t,s),this.mapFunction=e}*[Symbol.iterator](){for(let[t,e]of this.iterable){const[s,i]=this.mapFunction.call(this.ctx,e,t,this);yield[s,i]}}get(t){if(this.iterable.has(t)){const e=this.iterable.get(t);return this.mapFunction.call(this.ctx,e,t,this)[1]}}}class v extends h{constructor(t,e){super(),this.iterable=t,this.otherIterable=e}get size(){return this.iterable.size+this.otherIterable.size}*[Symbol.iterator](){yield*this.iterable,yield*this.otherIterable}optionalGet(t){const e=this.iterable.optionalGet(t);return e.has?e:this.otherIterable.optionalGet(t)}has(t){return this.iterable.has(t)||this.otherIterable.has(t)}get(t){return this.iterable.get(t)||this.otherIterable.get(t)}}class A extends n{constructor(t,e){super(),this.iterable=t,this.otherIterable=e}get size(){return this.iterable.size+this.otherIterable.size}has(t,e=-1){return super.has(t,e)||this.otherIterable.has(t,e)}*[Symbol.iterator](){yield*this.iterable,yield*this.otherIterable}}class E extends b{constructor(t,e,s){super(t,s),this.mapFunction=e}*[Symbol.iterator](){for(let[t,e]of this.iterable)yield this.mapFunction.call(this.ctx,e,t,this)}has(t){return!!Array.isArray(t)&&this.iterable.some(e=>i(t,e))}}class T extends b{constructor(t,e,s){super(t,s),this.mapFunction=e}*[Symbol.iterator](){for(let t of this.iterable)yield this.mapFunction.call(this.ctx,t,t,this)}has(t,e=-1){return Array.isArray(t)?this.some(s=>i(t,s,e)):this.some(e=>s(t,e))}}class G extends b{constructor(t,e,s){super(t,s),this.filterPredicate=e}get size(){let t=0;for(const e of this)t++;return t}*[Symbol.iterator](){for(let t of this.iterable)this.filterPredicate.call(this.ctx,t,t,this)&&(yield t)}has(t,e=-1){return!!this.iterable.has(t,e)&&this.filterPredicate.call(this.ctx,t,t,this)}}module.exports={HashMap:u,LinkedHashMap:c,Mootable:{HashMap:u,LinkedHashMap:c,hashCode:t,SetIterable:n,MapIterable:h}};
//# sourceMappingURL=hashmap.modern.js.map
