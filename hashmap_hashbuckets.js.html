<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>hashmap/hashbuckets.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HashMap.html">HashMap</a><ul class='methods'><li data-type='method' style='display: none;'><a href="HashMap.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#emplace">emplace</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#entries">entries</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#entriesRight">entriesRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#every">every</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#find">find</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findKey">findKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findLast">findLast</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findLastKey">findLastKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#forEach">forEach</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#forEachRight">forEachRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#get">get</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#has">has</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keyOf">keyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keysRight">keysRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#lastKeyOf">lastKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFind">optionalFind</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindKey">optionalFindKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindLast">optionalFindLast</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindLastKey">optionalFindLastKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalGet">optionalGet</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalKeyOf">optionalKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalLastKeyOf">optionalLastKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#reduceRight">reduceRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#set">set</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#some">some</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#values">values</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#valuesRight">valuesRight</a></li></ul></li><li><a href="LinkedHashMap.html">LinkedHashMap</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#emplace">emplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#emplaceLeft">emplaceLeft</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#entries">entries</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#entriesRight">entriesRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#every">every</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#find">find</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findKey">findKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findLast">findLast</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findLastKey">findLastKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#forEach">forEach</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#forEachRight">forEachRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#get">get</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#has">has</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#head">head</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#headKey">headKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keyOf">keyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keysRight">keysRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#lastKeyOf">lastKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFind">optionalFind</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindKey">optionalFindKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindLast">optionalFindLast</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindLastKey">optionalFindLastKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalGet">optionalGet</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalHead">optionalHead</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalHeadKey">optionalHeadKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalKeyOf">optionalKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalLastKeyOf">optionalLastKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalTail">optionalTail</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalTailKey">optionalTailKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#pop">pop</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#push">push</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#pushEmplace">pushEmplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reduceRight">reduceRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reverse">reverse</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#set">set</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#setLeft">setLeft</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#shift">shift</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#some">some</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#tail">tail</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#tailKey">tailKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#unshift">unshift</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#unshiftEmplace">unshiftEmplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#values">values</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#valuesRight">valuesRight</a></li></ul></li><li><a href="Option.html">Option</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Option.html#.some">some</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-@mootable_hashmap.html">@mootable/hashmap</a></li></ul><h3>Namespaces</h3><ul><li><a href="Mootable.html">Mootable</a></li><li></li><li></li><li><a href="Mootable.Hash.html">Hash</a></li><li><a href="Mootable.HashMap.html">HashMap</a></li><li><a href="Mootable.Utils.html">Utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#abstractEquals">abstractEquals</a></li><li><a href="global.html#equalsAndHash">equalsAndHash</a></li><li><a href="global.html#equalsFor">equalsFor</a></li><li><a href="global.html#hammingWeight">hammingWeight</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hashCodeFor">hashCodeFor</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isIterable">isIterable</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#none">none</a></li><li><a href="global.html#sameValue">sameValue</a></li><li><a href="global.html#sameValueZero">sameValueZero</a></li><li><a href="global.html#some">some</a></li><li><a href="global.html#strictEquals">strictEquals</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">hashmap/hashbuckets.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {none} from '../option/';

const SHIFT = 7;
const WIDTH = 1 &lt;&lt; SHIFT;
const MASK = WIDTH - 1;
const DEPTH = 5;

const SHIFT_HAMT = 5;
const WIDTH_HAMT = 1 &lt;&lt; SHIFT_HAMT;
const MASK_HAMT = WIDTH_HAMT - 1;
const DEPTH_HAMT = DEPTH - 1;

/**
 * @private
 */
export class HashBuckets {
    constructor(map) {
        this.map = map;
        this.buckets = [];
        this.size = 0;
    }

    clear() {
        this.buckets = [];
        this.size = 0;
    }

    bucketFor(hash) {
        const idx = hash &amp; MASK;
        if (idx &lt; this.buckets.length) {
            return this.buckets[idx];
        }
        return undefined;
    }

    set(key, value, options) {
        const hash = options.hash;
        const idx = hash &amp; MASK;
        let bucket = this.buckets[idx];
        if (!bucket) {
            bucket = this.map.createContainer(this, hash);
            bucket.createEntry(key, value,options);
            this.buckets[idx] = bucket;
            this.size += 1;
            return;
        } else if (bucket.hashConflicts(hash)) {
            bucket = new HamtBuckets(this.map, this, DEPTH_HAMT, SHIFT).replacing(bucket);
            this.buckets[idx] = bucket;
        }
        this.size -= bucket.size;
        bucket.set(key, value, options);
        this.size += bucket.size;
    }

    emplace(key, handler, options) {
        const hash = options.hash;
        const idx = hash &amp; MASK;
        let bucket = this.buckets[idx];
        if (!bucket) {
            bucket = this.map.createContainer(this, hash);
            this.buckets[idx] = bucket;
        } else if (bucket.hashConflicts(hash)) {
            bucket = new HamtBuckets(this.map, this, DEPTH_HAMT, SHIFT).replacing(bucket);
            this.buckets[idx] = bucket;
        }
        this.size -= bucket.size;
        const value = bucket.emplace(key, handler, options);
        this.size += bucket.size;
        return value;
    }

    delete(key, options) {
        const hash = options.hash;
        const idx = hash &amp; MASK;
        const bucket = this.buckets[idx];
        if (bucket) {
            const deleted = bucket.delete(key, options);
            if (deleted) {
                this.size -= 1;
                return true;
            }
        }
        return false;
    }

    get(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.get(key, options);
        }
        return undefined;
    }

    optionalGet(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.optionalGet(key, options);
        }
        return none;
    }

    has(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.has(key, options);
        }
        return false;
    }

    * [Symbol.iterator]() {
        for (const bucket of this.buckets) {
            if (bucket) {
                yield* bucket;
            }
        }
    }

    * entriesRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            const bucket = this.buckets[idx];
            if (bucket) {
                yield* bucket.entriesRight();
            }
        }
    }

    * keys() {
        for (const bucket of this.buckets) {
            if (bucket) {
                yield* bucket.keys();
            }
        }
    }

    * values() {
        for (const bucket of this.buckets) {
            if (bucket) {
                yield* bucket.values();
            }
        }
    }

    * keysRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            const bucket = this.buckets[idx];
            if (bucket) {
                yield* bucket.keysRight();
            }
        }
    }

    * valuesRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            const bucket = this.buckets[idx];
            if (bucket) {
                yield* bucket.valuesRight();
            }
        }
    }
}

/**
 * @private
 */
export class HamtBuckets {
    constructor(map, parent, depth, shift) {
        this.map = map;
        this.parent = parent;
        this.buckets = [];
        this.size = 0;
        this.idxFlags = 0;
        this.depth = depth;
        this.shift = shift;
    }

    hashConflicts() {
        return false;
    }

    clear() {
        this.size = 0;
        this.buckets = [];
        this.idxFlags = 0;
    }

    bucketFor(hash) {
        const idxFlags = this.idxFlags;
        const hashIdx = (hash >>> this.shift) &amp; MASK_HAMT;
        const flag = 1 &lt;&lt; hashIdx;
        const idx = hammingWeight(idxFlags &amp; (flag - 1));

        if (idxFlags &amp; flag) {
            return this.buckets[idx];
        }
        return undefined;
    }

    replacing(oldBucket) {
        const new_flag = 1 &lt;&lt; ((oldBucket.hash >>> this.shift) &amp; MASK_HAMT);
        this.idxFlags |= new_flag;
        // shift the old bucket up a level. no need to splice its always going to be the first item.
        this.buckets[0] = oldBucket;
        this.size = oldBucket.size;
        oldBucket.parent = this;
        return this;
    }

    set(key, value, options) {
        const hash = options.hash;
        const idxFlags = this.idxFlags;
        const hashIdx = (hash >>> this.shift) &amp; MASK_HAMT;
        const flag = 1 &lt;&lt; hashIdx;
        const idx = hammingWeight(idxFlags &amp; (flag - 1));
        let bucket;
        if (idxFlags &amp; flag) {
            bucket = this.buckets[idx];
            if (this.depth &amp;&amp; bucket.hashConflicts(hash)) {
                bucket = new HamtBuckets(this.map, this, this.depth - 1, this.shift + SHIFT_HAMT)
                    .replacing(bucket);
                this.buckets[idx] = bucket;
            }
            this.size -= bucket.size;
            bucket.set(key, value, options);
            this.size += bucket.size;
        } else {
            bucket = this.map.createContainer(this, hash);
            bucket.createEntry(key, value,options);
            this.buckets.splice(idx, 0, bucket);
            this.idxFlags |= flag;
            this.size += 1;
        }
    }

    emplace(key, handler, options) {
        const hash = options.hash;
        const idxFlags = this.idxFlags;
        const hashIdx = (hash >>> this.shift) &amp; MASK_HAMT;
        const flag = 1 &lt;&lt; hashIdx;
        const idx = hammingWeight(idxFlags &amp; (flag - 1));
        let bucket;
        if (idxFlags &amp; flag) {
            bucket = this.buckets[idx];
            if (this.depth &amp;&amp; bucket.hashConflicts(hash)) {
                bucket = new HamtBuckets(this.map, this, this.depth - 1, this.shift + SHIFT_HAMT)
                    .replacing(bucket);
                this.buckets[idx] = bucket;
            }
        } else {
            bucket = this.map.createContainer(this, hash);
            this.buckets.splice(idx, 0, bucket);
            this.idxFlags |= flag;
        }
        this.size -= bucket.size;
        const value = bucket.emplace(key, handler, options);
        this.size += bucket.size;
        return value;
    }

    delete(key, options) {
        const hash = options.hash;
        const idxFlags = this.idxFlags;
        const hashIdx = (hash >>> this.shift) &amp; MASK_HAMT;
        const flag = 1 &lt;&lt; hashIdx;
        if (idxFlags &amp; flag) {
            const idx = hammingWeight(idxFlags &amp; (flag - 1));
            const bucket = this.buckets[idx];
            const deleted = bucket.delete(key, options);
            if (deleted) {
                this.size -= 1;
                if (bucket.size === 0) {
                    if (idx === 0) {
                        this.buckets.shift();
                    } else if (this.buckets.length === idx+1) {
                        this.buckets.pop();
                    } else {
                        this.buckets.splice(idx, 1);
                    }
                    this.idxFlags ^= flag;
                }
                return true;
            }
        }
        return false;
    }

    get(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.get(key, options);
        }
        return undefined;
    }

    optionalGet(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.optionalGet(key, options);
        }
        return none;
    }

    has(key, options) {
        const hash = options.hash;
        const bucket = this.bucketFor(hash);
        if (bucket) {
            return bucket.has(key, options);
        }
        return false;
    }

    * [Symbol.iterator]() {
        for (const bucket of this.buckets) {
            yield* bucket;
        }
    }

    * entriesRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            yield* this.buckets[idx].entriesRight();
        }
    }

    * keys() {
        for (const bucket of this.buckets) {
            yield* bucket.keys();
        }
    }

    * values() {
        for (const bucket of this.buckets) {
            yield* bucket.values();
        }
    }
    * keysRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            yield* this.buckets[idx].keysRight();
        }
    }

    * valuesRight() {
        for (let idx = this.buckets.length - 1; idx >= 0; idx--) {
            yield* this.buckets[idx].valuesRight();
        }
    }
}

/**
 * Counts the number of ones in a 32 bit integer.
 *
 * @param {number} flags 32 bit integet
 * @return {number} amount of ones.
 */
export const hammingWeight = (flags) => {
    flags -= ((flags >>> 1) &amp; 0x55555555);
    flags = (flags &amp; 0x33333333) + ((flags >>> 2) &amp; 0x33333333);
    return ((flags + (flags >> 4) &amp; 0xF0F0F0F) * 0x1010101) >>> 24;
};</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Wed Apr 21 2021 00:42:49 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


    <link type="text/css" rel="stylesheet" href="docs.css">
    
</body>
</html>
