<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>linkedhashmap/index.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HashMap.html">HashMap</a><ul class='methods'><li data-type='method' style='display: none;'><a href="HashMap.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#emplace">emplace</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#entries">entries</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#entriesRight">entriesRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#every">every</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#find">find</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findKey">findKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findLast">findLast</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#findLastKey">findLastKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#forEach">forEach</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#forEachRight">forEachRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#get">get</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#has">has</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keyOf">keyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#keysRight">keysRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#lastKeyOf">lastKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFind">optionalFind</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindKey">optionalFindKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindLast">optionalFindLast</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalFindLastKey">optionalFindLastKey</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalGet">optionalGet</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalKeyOf">optionalKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#optionalLastKeyOf">optionalLastKeyOf</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#reduceRight">reduceRight</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#set">set</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#some">some</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#values">values</a></li><li data-type='method' style='display: none;'><a href="HashMap.html#valuesRight">valuesRight</a></li></ul></li><li><a href="LinkedHashMap.html">LinkedHashMap</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#copy">copy</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#emplace">emplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#emplaceLeft">emplaceLeft</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#entries">entries</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#entriesRight">entriesRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#every">every</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#find">find</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findKey">findKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findLast">findLast</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#findLastKey">findLastKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#forEach">forEach</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#forEachRight">forEachRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#get">get</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#has">has</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#head">head</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#headKey">headKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keyOf">keyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#keysRight">keysRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#lastKeyOf">lastKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFind">optionalFind</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindKey">optionalFindKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindLast">optionalFindLast</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalFindLastKey">optionalFindLastKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalGet">optionalGet</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalHead">optionalHead</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalHeadKey">optionalHeadKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalKeyOf">optionalKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalLastKeyOf">optionalLastKeyOf</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalTail">optionalTail</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#optionalTailKey">optionalTailKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#pop">pop</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#push">push</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#pushEmplace">pushEmplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reduceRight">reduceRight</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#reverse">reverse</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#set">set</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#setLeft">setLeft</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#shift">shift</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#some">some</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#tail">tail</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#tailKey">tailKey</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#unshift">unshift</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#unshiftEmplace">unshiftEmplace</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#values">values</a></li><li data-type='method' style='display: none;'><a href="LinkedHashMap.html#valuesRight">valuesRight</a></li></ul></li><li><a href="Option.html">Option</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Option.html#.some">some</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-@mootable_hashmap.html">@mootable/hashmap</a></li></ul><h3>Namespaces</h3><ul><li><a href="Mootable.html">Mootable</a></li><li></li><li></li><li><a href="Mootable.Hash.html">Hash</a></li><li><a href="Mootable.HashMap.html">HashMap</a></li><li><a href="Mootable.Utils.html">Utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#abstractEquals">abstractEquals</a></li><li><a href="global.html#equalsAndHash">equalsAndHash</a></li><li><a href="global.html#equalsFor">equalsFor</a></li><li><a href="global.html#hammingWeight">hammingWeight</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hashCodeFor">hashCodeFor</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isIterable">isIterable</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#none">none</a></li><li><a href="global.html#sameValue">sameValue</a></li><li><a href="global.html#sameValueZero">sameValueZero</a></li><li><a href="global.html#some">some</a></li><li><a href="global.html#strictEquals">strictEquals</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">linkedhashmap/index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {HashMap} from '../hashmap/';
import {Container} from '../hashmap/container';
import {some, none} from "../option";

/**
 * HashMap - LinkedHashMap Implementation for JavaScript
 * @namespace Mootable
 * @author Jack Moxley &lt;https://github.com/jackmoxley>
 * @version 1.0.2
 * Homepage: https://github.com/mootable/hashmap
 */
/**
 * This LinkedHashMap is is an extension of {@link HashMap} however LinkedHashMap also maintains insertion order of keys, and guarantees to iterate over them in that order.
 * @extends HashMap
 */
export class LinkedHashMap extends HashMap {

    /**
     * This LinkedHashMap is is an extension of {@link HashMap} however LinkedHashMap also maintains insertion order of keys, and guarantees to iterate over them in that order.
     * - `new LinkedHashMap()` creates an empty linked hashmap
     * - `new LinkedHashMap(copy:Iterable)` creates a linked hashmap which is a copy of the provided iterable.
     *   - One of
     *      - an object that provides a [Symbol.Iterator] function with the same signature as `Map.[Symbol.Iterator]`, such as `Map` or this `HashMap` and `LinkedHashMap`
     *          - or a 2 dimensional key-value array, e.g. `[['key1','val1'], ['key2','val2']]`.
     *      - an object that provides a entries function with the same signature as `Map.entries`, such as `Map` or this `HashMap` and `LinkedHashMap`
     *      - an object that provides a forEach function with the same signature as `Map.forEach`, such as `Map` or this `HashMap` and `LinkedHashMap`
     *
     * @example &lt;caption>Create an empty LinkedHashMap&lt;/caption>
     * const linkedhashmap = new LinkedHashMap();
     * // linkedhashmap.size === 0;
     * @example &lt;caption>Create LinkedHashMap from an array of key value pairs&lt;/caption>
     * const arr = [[1,'value1'],[2,'value2'],[3,'value3']];
     * const linkedhashmap = new LinkedHashMap(arr);
     * // linkedhashmap.size === 3;
     * @example &lt;caption>Create LinkedHashMap from another map&lt;/caption>
     * const map = new Map([[1,'value1'],[2,'value2'],[3,'value3']])
     * const linkedhashmap = new LinkedHashMap(map);
     * // linkedhashmap.size === 3;
     * @example &lt;caption>Create LinkedHashMap from another HashMap&lt;/caption>
     * const first = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']])
     * const linkedhashmap = new LinkedHashMap(first);
     * // linkedhashmap.size === 3;
     * // will accept LinkedHashMap as well
     * @example &lt;caption>Create LinkedHashMap from a class with symbol iterator&lt;/caption>
     * class MyIterable = {
     *     *[Symbol.iterator] () {
     *         yield ["key1", "value1"];
     *         yield ["key2", "value2"];
     *         yield ["key3", "value3"];
     *         yield ["key4", "value4"];
     *     }
     * }
     * const iterable = new MyIterable();
     * const linkedhashmap = new LinkedHashMap(iterable);
     * // linkedhashmap.size === 4;
     * // it doesn't have to be a generator, an iterator works too.
     * @example &lt;caption>Create LinkedHashMap from an object with an entries generator function&lt;/caption>
     * const entriesObj = {
     *     entries: function* () {
     *         yield ["key1", "value1"];
     *         yield ["key2", "value2"];
     *         yield ["key3", "value3"];
     *         yield ["key4", "value4"];
     *     }
     * }
     * const linkedhashmap = new LinkedHashMap(entriesObj);
     * // linkedhashmap.size === 4;
     * // it doesn't have to be a generator, an iterator works too.
     * @example &lt;caption>Create LinkedHashMap from an object with a forEach function&lt;/caption>
     * const forEachObj = {
     *      forEach: (callback, ctx) => {
     *              for (let i = 1; i &lt;= 4; i++) {
     *                  callback.call(ctx, 'value' + i, 'key' + i);
     *              }
     *      }
     * };
     * const linkedhashmap = new LinkedHashMap(forEachObj);
     * // linkedhashmap.size === 4;
     * @param {(Map|HashMap|LinkedHashMap|Iterable.&lt;Array.&lt;key,value>>|Object)} [copy]
     */
    constructor(copy) {
        super(copy);
        if (this.size === 0) {
            this.start = undefined;
            this.end = undefined;
        }
    }

    /**
     * @inheritDoc
     * @return {HashMap}
     */
    clear() {
        this.start = undefined;
        this.end = undefined;
        return super.clear();
    }

    /**
     *
     * @param key
     * @param value
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {LinkedHashMap}
     */
    setLeft(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.addToStart = true;
        this.buckets.set(key, value, op);
        return this;
    }

    /**
     *
     * @param key
     * @param handler
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {*}
     */
    emplaceLeft(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.addToStart = true;
        return this.buckets.emplace(key, handler, op);
    }

    /**
     *
     * @param key
     * @param value
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {LinkedHashMap}
     */
    push(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        this.buckets.set(key, value, op);
        return this;
    }

    /**
     *
     * @param key
     * @param handler
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {*}
     */
    pushEmplace(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        return this.buckets.emplace(key, handler, op);
    }

    /**
     *
     * @param key
     * @param value
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {LinkedHashMap}
     */
    unshift(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        op.addToStart = true;
        this.buckets.set(key, value, op);
        return this;
    }

    /**
     *
     * @param key
     * @param handler
     * @param {HashMap#overrides&lt;equals, hash>} [overrides] - a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     * @return {HashMap}
     * @return {*}
     */
    unshiftEmplace(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        op.addToStart = true;
        return this.buckets.emplace(key, handler, op);
    }

    /**
     *
     * @return {undefined|*}
     */
    shift() {
        const entry = this.start;
        if (entry) {
            entry.parent.deleteEntry(entry);
            return entry.slice();
        }
        return undefined;
    }

    /**
     *
     * @return {undefined|*}
     */
    pop() {
        const entry = this.end;
        if (entry) {
            entry.parent.deleteEntry(entry);
            return entry.slice();
        }
        return undefined;
    }

    /**
     *
     * @return {undefined|*}
     */
    head() {
        const entry = this.start;
        if (entry) {
            return entry[1];
        }
        return undefined;
    }

    /**
     *
     * @return {undefined|*}
     */
    tail() {
        const entry = this.end;
        if (entry) {
            return entry[1];
        }
        return undefined;
    }

    /**
     *
     * @return {Option}
     */
    optionalHead() {
        const entry = this.start;
        if (entry) {
            return some(entry[1]);
        }
        return none;
    }

    /**
     *
     * @return {Option}
     */
    optionalTail() {
        const entry = this.end;
        if (entry) {
            return some(entry[1]);
        }
        return none;
    }

    /**
     *
     * @return {undefined|*}
     */
    headKey() {
        const entry = this.start;
        if (entry) {
            return entry[0];
        }
        return undefined;
    }

    /**
     *
     * @return {undefined|*}
     */
    tailKey() {
        const entry = this.end;
        if (entry) {
            return entry[0];
        }
        return undefined;
    }

    /**
     *
     * @return {Option}
     */
    optionalHeadKey() {
        const entry = this.start;
        if (entry) {
            return some(entry[0]);
        }
        return none;
    }

    /**
     *
     * @return {Option}
     */
    optionalTailKey() {
        const entry = this.end;
        if (entry) {
            return some(entry[0]);
        }
        return none;
    }

    /**
     * @inheritDoc
     * @return {LinkedHashMap}
     */
    reverse(){
        if(this.size > 1){
            let entry = this.start;
            do {
                const previous = entry.previous;
                const next = entry.next;
                entry.previous = next;
                entry.next = previous;
                entry = next;
            } while(entry);
            const start = this.start;
            this.start = this.end;
            this.end = start;
        }
        return this;
    }

    /**
     * Makes a copy of this LinkedHashMap
     * @return {LinkedHashMap}
     */
    clone() {
        return new LinkedHashMap(this);
    }

    /**
     * Iterates over all the entries in the map.
     *
     * @yields {entries:Array.&lt;key,value>} each entry in the map
     */
    * [Symbol.iterator]() {
        yield* this.entries();
    }
    /**
     * Iterates over all the entries in the map.
     *
     * @yields {entries:Array.&lt;key,value>} each entry in the map
     */
    * entries() {
        let entry = this.start;
        while (entry) {
            yield entry.slice();
            entry = entry.next;
        }
    }

    /**
     * Iterates over all the entries in the map in reverse order.
     *
     * @yields {entries:Array.&lt;key,value>} each entry in the map in reverse order
     */
    * entriesRight() {
        let entry = this.end;
        while (entry) {
            yield entry.slice();
            entry = entry.previous;
        }
    }

    /**
     * Iterates over all the keys in the map.
     *
     * @yields {key:any} each key in the map
     */
    * keys() {
        let entry = this.start;
        while (entry) {
            yield entry[0];
            entry = entry.next;
        }
    }

    /**
     * Iterates over all the values in the map.
     *
     * @yields {value:any} each value in the map
     */
    * values() {
        let entry = this.start;
        while (entry) {
            yield entry[1];
            entry = entry.next;
        }
    }

    /**
     * Iterates over all the keys in the map in reverse.
     * @yields {key:any} each key in the map in reverse order
     */
    * keysRight() {
        let entry = this.end;
        while (entry) {
            yield entry[0];
            entry = entry.previous;
        }
    }

    /**
     * Iterates over all the values in the map in reverse.
     * @yields {value:any} each value in the map in reverse order
     */
    * valuesRight() {
        let entry = this.end;
        while (entry) {
            yield entry[1];
            entry = entry.previous;
        }
    }

// private

    /**
     * @private
     * @param parent
     * @param hash
     * @return {LinkedContainer}
     */
    createContainer(parent, hash) {
        return new LinkedContainer(this, parent, hash);
    }
}


/**
 * Holds multiple entries, but shrinks to a single container if reduced to a size of one.
 * @private
 */
export class LinkedContainer extends Container {

    constructor(map, parent, hash) {
        super(map, parent, hash);
    }

    createEntry(key, value, overrides) {
        const entry = super.createEntry(key, value, overrides);
        const map = this.map;
        if (map.start === undefined) {
            map.end = map.start = entry;
        } else if (overrides.addToStart) {
            map.start.previous = entry;
            entry.next = map.start;
            map.start = entry;
        } else {
            map.end.next = entry;
            entry.previous = map.end;
            map.end = entry;
        }
        return entry;
    }

    updateEntry(entry, newValue, overrides) {
        super.updateEntry(entry, newValue, overrides);
        if (overrides.moveOnUpdate) {
            if (overrides.addToStart) {
                if (entry.previous) {
                    if (entry.next) {
                        entry.next.previous = entry.previous;
                    }
                    entry.previous.next = entry.next;
                    if (entry === this.map.end) {
                        this.map.end = entry.previous;
                    }
                    entry.previous = undefined;
                    this.map.start.previous = entry;
                    entry.next = this.map.start;
                    this.map.start = entry;
                }
            } else if (entry.next) {
                if (entry.previous) {
                    entry.previous.next = entry.next;
                }
                entry.next.previous = entry.previous;
                if (entry === this.map.start) {
                    this.map.start = entry.next;
                }
                entry.next = undefined;
                this.map.end.next = entry;
                entry.previous = this.map.end;
                this.map.end = entry;
            }
        }
    }

    deleteIndex(idx) {
        const oldEntry = super.deleteIndex(idx);
        const map = this.map;
        if (oldEntry.previous) {
            oldEntry.previous.next = oldEntry.next;
        } else {
            map.start = oldEntry.next;
        }
        if (oldEntry.next) {
            oldEntry.next.previous = oldEntry.previous;
        } else {
            map.end = oldEntry.previous;
        }
    }
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Wed Apr 28 2021 01:04:23 GMT+0100 (British Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


    <link type="text/css" rel="stylesheet" href="docs.css">
    
</body>
</html>
