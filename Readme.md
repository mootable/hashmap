![The Moo Tableau](mootableau_sm.png)

# HashMap & LinkedHashMap

## Description

This project provides `HashMap` and `LinkedHashMap` classes that works both on **Node.js** and the **browser**.

*   They are both implementations of a simplified [HAMT](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) like [hash trie](https://en.wikipedia.org/wiki/Hash_tree_\(persistent_data_structure\))
*   It uses a modified [Murmer 3](https://en.wikipedia.org/wiki/MurmurHash) algorithm for generating hashes. This ensures the widest possible spread across all buckets.
*   As per spec, the basic `Hashmap` is not guaranteed to meet order of insertion when iterating over it. If you want guaranteed insertion order when iterating, use `LinkedHashMap`.
*   The keys are truly typed and unique, this means 1 !== "1".

### Choose your map wisely.

*   When choosing a collection it is worth understanding the problem you are trying to solve.
*   [Native JS Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) for small numbers of entries, will be significantly faster.
*   However once the map reaches 1'000 or more the Mootable Hashmap really shows its strengths. It utilizes more memory, to do this.
*   The [Native JS Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) is likely to have improved speed characteristics if repeating operations in a loop, via things such as JIT compilation. It is worth benchmarking to see if Map works better for you in those situations.

## Installation

[![NPM](https://nodei.co/npm/@mootable/hashmap.png?compact=true)](https://npmjs.org/package/@mootable/hashmap)

Using [npm](https://npmjs.org/package/@mootable/hashmap):

    $ npm install @mootable/hashmap

You can download the last stable version from the [releases page](https://github.com/mootable/hashmap/releases).

If you like risk, you can download the [latest master version](https://raw.github.com/mootable/hashmap/master/hashmap.js), it's usually stable.

To run the tests:

    $ npm test

To run the benchmarks: (Ensure you have the memory to run them)

*   If you don't you can reduce the memory size (in MB) accordingly `--max_old_space_size` and remove the last items in `MAP_SIZES`

    $ node  --max_old_space_size=24576 --expose-gc test\benchmark.js

## [API](https://mootable.github.io/hashmap/)

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

#### Table of Contents

*   [HashMap](#hashmap)
    *   [Parameters](#parameters)
    *   [size](#size)
    *   [length](#length)
    *   [has](#has)
    *   [get](#get)
    *   [keyOf](#keyof)
    *   [lastKeyOf](#lastkeyof)
    *   [optionalKeyOf](#optionalkeyof)
    *   [optionalLastKeyOf](#optionallastkeyof)
    *   [optionalGet](#optionalget)
    *   [find](#find)
    *   [findLast](#findlast)
    *   [optionalFind](#optionalfind)
    *   [optionalFindLast](#optionalfindlast)
    *   [findKey](#findkey)
    *   [findLastKey](#findlastkey)
    *   [optionalFindKey](#optionalfindkey)
    *   [optionalFindLastKey](#optionalfindlastkey)
    *   [set](#set)
    *   [emplace](#emplace)
    *   [copy](#copy)
    *   [clone](#clone)
    *   [delete](#delete)
    *   [clear](#clear)
    *   [forEach](#foreach)
    *   [forEachRight](#foreachright)
    *   [every](#every)
    *   [some](#some)
    *   [reduce](#reduce)
    *   [reduceRight](#reduceright)
    *   [iterator](#iterator)
    *   [entries](#entries)
    *   [entriesRight](#entriesright)
    *   [keys](#keys)
    *   [values](#values)
    *   [keysRight](#keysright)
    *   [valuesRight](#valuesright)
*   [LinkedHashMap](#linkedhashmap)
    *   [Parameters](#parameters-26)
    *   [clear](#clear-1)
    *   [setLeft](#setleft)
    *   [emplaceLeft](#emplaceleft)
    *   [push](#push)
    *   [pushEmplace](#pushemplace)
    *   [unshift](#unshift)
    *   [unshiftEmplace](#unshiftemplace)
    *   [shift](#shift)
    *   [pop](#pop)
    *   [head](#head)
    *   [tail](#tail)
    *   [optionalHead](#optionalhead)
    *   [optionalTail](#optionaltail)
    *   [headKey](#headkey)
    *   [tailKey](#tailkey)
    *   [optionalHeadKey](#optionalheadkey)
    *   [optionalTailKey](#optionaltailkey)
    *   [reverse](#reverse)
    *   [clone](#clone-1)
    *   [iterator](#iterator-1)
    *   [entries](#entries-1)
    *   [entriesRight](#entriesright-1)
    *   [keys](#keys-1)
    *   [values](#values-1)
    *   [keysRight](#keysright-1)
    *   [valuesRight](#valuesright-1)
*   [Option](#option)
    *   [Parameters](#parameters-33)
    *   [Examples](#examples-26)
    *   [size](#size-1)
    *   [iterator](#iterator-2)
    *   [none](#none)
    *   [some](#some-1)
*   [HashMap#overrideEquals](#hashmapoverrideequals)
    *   [Parameters](#parameters-35)
*   [HashMap#overrideHash](#hashmapoverridehash)
    *   [Parameters](#parameters-36)
*   [HashMap#overrides](#hashmapoverrides)
    *   [Properties](#properties)
*   [HashMap#emplaceUpdate](#hashmapemplaceupdate)
    *   [Parameters](#parameters-37)
*   [HashMap#emplaceInsert](#hashmapemplaceinsert)
    *   [Parameters](#parameters-38)
*   [HashMap#emplaceHandler](#hashmapemplacehandler)
    *   [Properties](#properties-1)
*   [HashMap#ForEachCallback](#hashmapforeachcallback)
    *   [Parameters](#parameters-39)
    *   [Examples](#examples-30)
*   [HashMap#MatchesPredicate](#hashmapmatchespredicate)
    *   [Parameters](#parameters-40)
    *   [Examples](#examples-31)
*   [HashMap#ReduceFunction](#hashmapreducefunction)
    *   [Parameters](#parameters-41)
    *   [Examples](#examples-32)
*   [isFunction](#isfunction)
    *   [Parameters](#parameters-42)
    *   [Examples](#examples-33)
*   [isIterable](#isiterable)
    *   [Parameters](#parameters-43)
    *   [Examples](#examples-34)
*   [isString](#isstring)
    *   [Parameters](#parameters-44)
    *   [Examples](#examples-35)
*   [sameValue](#samevalue)
    *   [Parameters](#parameters-45)
*   [sameValueZero](#samevaluezero)
    *   [Parameters](#parameters-46)
*   [abstractEquals](#abstractequals)
    *   [Parameters](#parameters-47)
*   [strictEquals](#strictequals)
    *   [Parameters](#parameters-48)
*   [hammingWeight](#hammingweight)
    *   [Parameters](#parameters-49)
    *   [Examples](#examples-36)
*   [hash](#hash)
    *   [Parameters](#parameters-50)
*   [hashCodeFor](#hashcodefor)
    *   [Parameters](#parameters-51)
*   [equalsFor](#equalsfor)
    *   [Parameters](#parameters-52)
*   [equalsAndHash](#equalsandhash)
    *   [Parameters](#parameters-53)
*   [some](#some-2)
    *   [Parameters](#parameters-54)
    *   [Examples](#examples-37)
*   [none](#none-1)
    *   [Examples](#examples-38)

### HashMap

This HashMap is backed by a Hash array mapped trie.

#### Parameters

*   `copy` **([Map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map) | [HashMap](#hashmap) | [LinkedHashMap](#linkedhashmap) | Iterable<[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)\<key, value>> | [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object))?** 

**Meta**

*   **copyright**: Jack Moxley <https://github.com/jackmoxley>
*   **author**: Jack Moxley

#### size

Returns the number of elements in this hashmap.

##### Examples

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const size = hashmap.size;
console.log(size);
// logs: 3
```

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** the number of elements in the array

#### length

Returns the number of elements in this hashmap.

##### Examples

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const length = hashmap.length;
console.log(length);
// logs: 3
```

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** the number of elements in the array

#### has

*   **See**: [Map.has](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has)

Does the map have this key.

*   return true if the <code>key</code> is in the map.
*   if no elements match, it returns false.
*   it is legitimate for keys to be null or undefined.

Maps typically index keys, and so is generally a fast operation.

##### Parameters

*   `key` **any** the matching key we use to identify if we have a match.
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hash and equals methods, rather than them being looked up.

##### Examples

Does this contain a key that is there

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const hasResult = hashmap.has(1);
// hasResult === true
```

Does this contain a key that isn't there

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const hasResult = hashmap.has(4);
// hasResult === false
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const key = new NameKey('John','Smith');
const hasResult = hashmap.has(key);
// hasResult === true
```

Advanced: using a custom hash and equals, to determine if there are entries for a specific hash

```javascript
const myHash = 3;
const hashEquals = {hash: myHash, equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const hasResult = hashmap.has(0, hashEquals);
// hasResult === true
// the hash of the number 3 is actually also 3. all 32 bit integers have the same hash.
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** if it holds the key or not.

#### get

*   **See**: [Map.get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get)

Get a value from the map using this key.

*   return the first <code>value</code> from the <code>\[key,value]</code> pair that matches the key.
*   if no elements match, it returns undefined.
*   it is legitimate for keys to be null or undefined, and if set, will find a value.
*   it is also legitimate for values to be null or undefined, as such get should never be used as an existence check. {@see HashMap#optionalGet}

Also provides a way to override both the equals and the hash
Performance:

*   will be O(1) approaching O(log n)

##### Parameters

*   `key` **any** the matching key we use to identify if we have a match.
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.

##### Examples

What is the value for a key

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.get(1);
// getResult === 'value1'
```

What is the value for a key that isn't there

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.get(4);
// getResult === undefined
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const key = new NameKey('John','Smith');
const getResult = hashmap.get(key);
// getResult === 'Librarian'
```

Advanced: using a custom hash and equals, to get the first entry for a specific hash

```javascript
const myHash = 3;
const hashEquals = {hash: myHash, equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.get(0, hashEquals);
// getResult === 'value3'
// the hash of the number 3 is actually also 3. all 32 bit integers have the same hash.
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **any** the value of the element that matches.

#### keyOf

*   **See**: [Array.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)

Get the key from the map using the provided value. Since values are not hashed, this has to check each value in the map until a value matches, or the whole map, if none match. As such this is a slow operation.
Performance O(n) as we have to iterate over the whole map, to find each value and perform
an equality against it.

##### Parameters

*   `value` **any** The value we are searching the map for
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals>?** an optional override to allow a user to
    define the equals methods, rather than it being looked up on the value.

##### Examples

What is the key for a value

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const keyOfResult = hashmap.keyOf('value2');
// keyOfResult === 2
```

What is the value for a key that isn't there

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const keyOfResult = hashmap.keyOf('value4');
// keyOfResult === undefined
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const keyOfResult = hashmap.keyOf('Engineer');
// getResult ~ NameKey('Orlando','Keleshian')
```

Advanced: using a custom equals, to get the first key in the
hashmap

```javascript
const myEquals = {equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const keyOfResult = hashmap.keyOf(0, myEquals);
// keyOfResult === 1
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **(any | [undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined))** the first key for this value or undefined

#### lastKeyOf

*   **See**: [Array.lastIndexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)

Get the key from the map using the provided value, searching the map in reverse. Since values
are not hashed, this has to check each value in the map until a value matches, or the
whole map, if none match. As such this is a slow operation.
Performance O(n) as we have to iterate over the whole map, to find each value and perform
an equality against it.

##### Parameters

*   `value` **any** The value we are searching the map for, (in reverse)
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals>?** an optional override to allow a user to
    define the equals methods, rather than it being looked up on the value.

##### Examples

What is the key for a value

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const lastKeyOfResult = hashmap.lastKeyOf('value2');
// lastKeyOfResult === 2
```

What is the value for a key that isn't there

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const lastKeyOfResult = hashmap.lastKeyOf('value4');
// lastKeyOfResult === undefined
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const lastKeyOfResult = hashmap.lastKeyOf('Engineer');
// getResult ~ NameKey('Orlando','Keleshian')
```

Advanced: using a custom equals, to get the last key in the
hashmap

```javascript
const myEquals = {equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const lastKeyOfResult = hashmap.lastKeyOf(0, myEquals);
// lastKeyOfResult === 3
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **(any | [undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined))** the last key for this value or undefined

#### optionalKeyOf

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)

Get the key from the map using the provided value, and wrap it in an [Option](#option).
Since values are not hashed, this has to check each value in the map until a value
matches, or the whole map, if none match. As such this is a slow operation.
Performance O(n) as we have to iterate over the whole map, to find each value and perform
an equality against it.

##### Parameters

*   `value` **any** The value we are searching the map for
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals>?** an optional overrides to allow a user to
    define the equals methods, rather than it being looked up on the value.

##### Examples

What is the key for a value

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalKeyOfResult = hashmap.optionalKeyOf('value2');
// optionalKeyOfResult === Option.some(2)
```

What is the value for a key that isn't there

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalKeyOfResult = hashmap.optionalKeyOf('value4');
// optionalKeyOfResult === Option.none
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const optionalKeyOfResult = hashmap.optionalKeyOf('Engineer');
// getResult ~ Option.some(NameKey('Orlando','Keleshian'))
```

Advanced: using a custom equals, to get the first key in the
hashmap

```javascript
const myEquals = {equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalKeyOfResult = hashmap.optionalKeyOf(0, myEquals);
// optionalKeyOfResult === Option.some(1)
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **[Option](#option)** the first key for this value or none

#### optionalLastKeyOf

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.lastIndexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)

Get the key from the map using the provided value, searching the map in reverse. Since values
are not hashed, this has to check each value in the map until a value matches, or the
whole map, if none match. As such this is a slow operation.
Performance O(n) as we have to iterate over the whole map, to find each value and perform
an equality against it.

##### Parameters

*   `value` **any** The value we are searching the map for, (in reverse)
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals>?** an optional overrides to allow a user to
    define the equals methods, rather than it being looked up on the value.

##### Examples

What is the key for a value

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalLastKeyOfResult = hashmap.optionalLastKeyOf('value2');
// optionalLastKeyOfResult === Option.some(2)
```

What is the value for a key that isn't there

```javascript
const hashmap = new LinkedHashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalLastKeyOfResult = hashmap.optionalLastKeyOf('value4');
// optionalLastKeyOfResult === Option.none
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const optionalLastKeyOfResult = hashmap.optionalLastKeyOf('Engineer');
// getResult ~ Option.some(NameKey('Orlando','Keleshian'))
```

Advanced: using a custom equals, to get the last key in the
hashmap

```javascript
const myEquals = {equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const optionalLastKeyOfResult = hashmap.optionalLastKeyOf(0, myEquals);
// optionalLastKeyOfResult === Option.some(3)
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **[Option](#option)** the last key for this value or none

#### optionalGet

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Map.get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get)

Get an optional value from the map. This is effectively a more efficent combination of calling has and get at the same time.

*   return the first <code>some(value)</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns <code>none()</code>.
*   it is legitimate for keys to be null or undefined, and if set, will still acknowledge it exists, against the key.

Maps typically index keys, and so is generally a fast operation.

##### Parameters

*   `key` **any** the key we use to identify if we have a match.
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.

##### Examples

What is the value for a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.optionalGet(1);
// getResult === Option.some('value1') {value:'value1',has:true}
```

What is the value for a key that isn't there

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.optionalGet(4);
// getResult === Option.none {has:false}
```

What is the value for a key with an undefined value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,undefined],[3,'value3']]);
const getResult = hashmap.optionalGet(2);
// getResult === Option.some(undefined) {value:undefined,has:true}
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap([[new NameKey('John','Smith'),'Librarian'],[new NameKey('Orlando','Keleshian'),'Engineer']]);
const key = new NameKey('John','Smith');
const getResult = hashmap.optionalGet(key);
// getResult === Option.some('Librarian') {value:'Librarian',has:true}
```

Advanced: using a custom hash and equals, to get the first entry for a specific hash

```javascript
const myHash = 3;
const hashEquals = {hash: myHash, equals: () => true}
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const getResult = hashmap.optionalGet(0, hashEquals);
// getResult === Option.some('value3')  {value:'value3',has:true}
// the hash of the number 3 is actually also 3. all 32 bit integers have the same hash.
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **[Option](#option)** an optional result.

#### find

*   **See**: [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

Find the first value in the map which passes the provided <code>MatchesPredicate</code>.

*   return the first <code>value</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first value it finds.

##### Parameters

*   `findPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>value`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findPredicate</code> (optional, default `undefined`)

##### Examples

Find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.endsWith('ue2'));
// findResult === 'value2'
```

Can't find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.startsWith('something'));
// findResult === undefined
```

Returns **any** the value of the element that matches.

#### findLast

*   **See**: [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

Find the first value in the map which passes the provided <code>MatchesPredicate</code>.

*   return the first <code>value</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first value it finds.

##### Parameters

*   `findPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>value`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findPredicate</code> (optional, default `undefined`)

##### Examples

Find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.endsWith('ue2'));
// findResult === 'value2'
```

Can't find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.startsWith('something'));
// findResult === undefined
```

Returns **any** the value of the element that matches.

#### optionalFind

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

Find the first value in the map which passes the provided <code>MatchesPredicate</code>.

*   return the first <code>value</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first value it finds.

##### Parameters

*   `findPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>value`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findPredicate</code> (optional, default `undefined`)

##### Examples

Find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.endsWith('ue2'));
// findResult === 'value2'
```

Can't find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.startsWith('something'));
// findResult === undefined
```

Returns **any** the value of the element that matches.

#### optionalFindLast

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)

Find the first value in the map which passes the provided <code>MatchesPredicate</code>.

*   return the first <code>value</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first value it finds.

##### Parameters

*   `findPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>value`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findPredicate</code> (optional, default `undefined`)

##### Examples

Find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.endsWith('ue2'));
// findResult === 'value2'
```

Can't find a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findResult = hashmap.find((value) => value.startsWith('something'));
// findResult === undefined
```

Returns **any** the value of the element that matches.

#### findKey

*   **See**: [Array.findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)

Find the first value in the key which passes the provided  <code>MatchesPredicate</code>.

*   return the first <code>key</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first key it finds.

##### Parameters

*   `findKeyPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>key`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findKeyPredicate</code> (optional, default `undefined`)

##### Examples

Find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.endsWith('ue2'));
// findIndexResult === 2
```

Can't find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.startsWith('something'));
// findIndexResult === undefined
```

Returns **any** the key of the element that matches..

#### findLastKey

*   **See**: [Array.prototype.findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)

Find the first value in the key which passes the provided  <code>MatchesPredicate</code>.

*   return the first <code>key</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first key it finds.

##### Parameters

*   `findKeyPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>key`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findKeyPredicate</code> (optional, default `undefined`)

##### Examples

Find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.endsWith('ue2'));
// findIndexResult === 2
```

Can't find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.startsWith('something'));
// findIndexResult === undefined
```

Returns **any** the key of the element that matches..

#### optionalFindKey

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.prototype.findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)

Find the first value in the key which passes the provided  <code>MatchesPredicate</code>.

*   return the first <code>key</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first key it finds.

##### Parameters

*   `findKeyPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>key`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findKeyPredicate</code> (optional, default `undefined`)

##### Examples

Find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.endsWith('ue2'));
// findIndexResult === 2
```

Can't find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.startsWith('something'));
// findIndexResult === undefined
```

Returns **any** the key of the element that matches..

#### optionalFindLastKey

*   **See**: [Option.some](#optionsome)
*   **See**: [Option.none](#optionnone)
*   **See**: [Array.prototype.findIndex](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)

Find the first value in the key which passes the provided  <code>MatchesPredicate</code>.

*   return the first <code>key</code> from the <code>\[key,value]</code> pair that matches
*   if no elements match, it returns undefined.
*   if no predicate is defined, will return the first key it finds.

##### Parameters

*   `findKeyPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>key`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>findKeyPredicate</code> (optional, default `undefined`)

##### Examples

Find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.endsWith('ue2'));
// findIndexResult === 2
```

Can't find a key

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const findIndexResult = hashmap.findIndex((value) => value.startsWith('something'));
// findIndexResult === undefined
```

Returns **any** the key of the element that matches..

#### set

*   **See**: [Map.prototype.set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set)

Sets a value onto this map, using the key as its reference.

##### Parameters

*   `key` **any** the key we want to key our value to
*   `value` **any** the value we are setting
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.

##### Examples

set a value

```javascript
const hashmap = new HashMap();
hashmap.set(1,'value1');
const hasResult = hashmap.has(1);
// hasResult === true
```

> overwrite a value

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2']]);
hashmap.set(2,'other');
const getResult = hashmap.get(2);
// getResult === 'other'
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const hashmap = new HashMap();
hashmap.set(new NameKey('John','Smith'),'Librarian');
const hasResult = hashmap.has(new NameKey('John','Smith'));
// hasResult === true
```

Advanced: using a custom hash and equals, to set a value to a specific
hash

```javascript
const hashmap = new HashMap();
hashmap.set(1,'value1', {hash: 3});
const hasResult = hashmap.has(3, {equals: () => true} );
// hasResult === true
// the hash of the number 3 is actually also 3. all 32 bit integers have the same hash.
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

Returns **[HashMap](#hashmap)** this hashmap

#### emplace

*   **See**: [upsert proposal](https://tc39.es/proposal-upsert/)
*   **See**: [Map.prototype.emplace](https://github.com/tc39/proposal-upsert)

Given a key and a handler object, the emplace method will either remap an existing entry,
insert a new entry from a mapping function, or both. emplace will return the updated or
inserted value.

##### Parameters

*   `key` **any** the key we want to key our value to
*   `handler` **[HashMap#emplaceHandler](#hashmapemplacehandler)\<insert, update>** the insert and update methods we
    want to use.
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.

##### Examples

insert into the map

```javascript
const hashmap = new HashMap();
const handler = {
    update: () => {
        return 'update';
    },
    insert: (key, map) => {
        return 'insert';
    }
};
const ret = hashmap.emplace('key', handler)
// hashmap = [['key', 'insert']]
// ret === 'insert'
```

update the map

```javascript
const hashmap = new HashMap([['key','value']]);
const handler = {
    update: () => {
        return 'update';
    },
    insert: (key, map) => {
        return 'insert';
    }
};
const ret = hashmap.emplace('key', handler)
// hashmap = [['key', 'update']]
// ret === 'update'
```

insert into the map if the key already exists without an update

```javascript
const hashmap = new HashMap([['key','value']]);
const handler = {
    insert: (key, map) => {
        return 'insert';
    }
};
const ret = hashmap.emplace('key', handler)
// hashmap = [['key', 'value']]
// ret === 'value'
```

update into the map without an insert method (throws an error)

```javascript
const hashmap = new HashMap([['key','value']]);
const handler = {
    update: (oldValue, key, map) => {
        return 'update';
    }
};
hashmap.emplace('key', handler)
// throws an Error as insert doesn't exist
// hashmap = [['key', 'value']]
```

Advanced: using a predefined hashCode and equals on the key

```javascript
class NameKey {
    constructor(firstName, secondName) {
        this.firstName = firstName;
        this.secondName = secondName;
    }
    hashCode() {
         return (Mootable.hash(firstName) * 31) +Mootable.hash(secondName);
    }
    equals(other) {
         return other && other instanceof NameKey && other.firstName === this.firstName && other.secondName === this.secondName;
    }
}
const handler = {
    insert: (key, map) => {
        return 'Librarian';
    }
};
const hashmap = new HashMap();
const ret = hashmap.emplace(new NameKey('John','Smith'),handler);
// ret === 'Librarian'
```

Advanced: using a custom hash and equals, to emplace a value to a specific
hash

```javascript
const handler = {
    insert: (key, map) => {
        return 'value1';
    }
};
const hashmap = new HashMap();
const ret = hashmap.emplace(1,handler, {hash: 3});
// ret === 'value1'
// the hash of the number 3 is actually also 3. all 32 bit integers have the same hash.
// 0 doesn't exist in the hashMap, but we are circumventing using the key entirely.
```

*   Throws **[Error](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Error)** if the insert method does not exist, and it can't find the key.

Returns **any** the new value that was set, or overwrote.

#### copy

Copies all the entries from the map, array or iterable, into this hashmap.

##### Parameters

*   `other` **([Map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map) | [HashMap](#hashmap) | [LinkedHashMap](#linkedhashmap) | Iterable<[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)\<key, value>> | [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object))** the
    iterable to copy

##### Examples

copy into the HashMap from an array of key value pairs

```javascript
const hashmap = new HashMap([['key0','value0']]);
const arr = [[1,'value1'],[2,'value2'],[3,'value3']];
hashmap.copy(arr);
// hashmap.size === 4;
```

copy into the HashMap from another map

```javascript
const hashmap = new HashMap([['key0','value0']]);
const map = new Map([[1,'value1'],[2,'value2'],[3,'value3']])
hashmap.copy(map);
// hashmap.size === 4;
```

copy into the HashMap from another HashMap

```javascript
const first = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']])
const hashmap = new HashMap(first);
// hashmap.size === 3;
```

copy into the HashMap from a class with symbol iterator

```javascript
const hashmap = new HashMap([['key0','value0']]);
class MyIterable = {
    *[Symbol.iterator] () {
        yield ["key1", "value1"];
        yield ["key2", "value2"];
        yield ["key3", "value3"];
        yield ["key4", "value4"];
    }
}
const iterable = new MyIterable();
hashmap.copy(iterable);
// hashmap.size === 5;
// it doesn't have to be a generator, an iterator works too.
```

copy into the HashMap from an object with an entries generator function

```javascript
const hashmap = new HashMap([['key0','value0']]);
const entriesObj = {
    entries: function* () {
        yield ["key1", "value1"];
        yield ["key2", "value2"];
        yield ["key3", "value3"];
        yield ["key4", "value4"];
    }
}
hashmap.copy(entriesObj);
// hashmap.size === 5;
// it doesn't have to be a generator, an iterator works too.
```

copy into the HashMap from an object with a forEach function

```javascript
const hashmap = new HashMap([['key0','value0']]);
const forEachObj = {
     forEach: (callback, ctx) => {
             for (let i = 1; i <= 4; i++) {
                 callback.call(ctx, 'value' + i, 'key' + i);
             }
     }
};
hashmap.copy(forEachObj);
// hashmap.size === 5;
```

*   Throws **[TypeError](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypeError)** if the provided object other is null or not iterable.

Returns **[HashMap](#hashmap)** this hashmap, with the values copied to it.

#### clone

Makes a full copy of this hashmap and returns the clone.

Returns **[HashMap](#hashmap)** 

#### delete

Deletes an entry from this hashmap, using the provided key

##### Parameters

*   `key`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

#### clear

Clears the data from this hashmap. All data is orphaned, and will be Garbage Collected.

Returns **[HashMap](#hashmap)** this hashmap

#### forEach

Execute the provided callback on every <code>\[key,value]</code> pair of this map iterable.

##### Parameters

*   `callback` **[HashMap#ForEachCallback](#hashmapforeachcallback)**  (optional, default `(value,key,map)=>{}`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>forEachCallback</code>

##### Examples

Log all the keys and values.

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
mapIterable.forEach((value) => console.log(key, value));
// will log to the console:
// 1 value1
// 2 value2
// 3 value3
// Ordering is deterministic on paper, but from a usability point of view effectively random
// as it is ordered by a mix of the hash of the key, and order of insertion.
```

Returns **[HashMap](#hashmap)** the hashmap you are foreaching on..

#### forEachRight

Execute the provided callback on every <code>\[key,value]</code> pair of this map iterable in reverse.

##### Parameters

*   `callback` **[HashMap#ForEachCallback](#hashmapforeachcallback)**  (optional, default `(value,key,map)=>{}`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>forEachCallback</code>

##### Examples

Log all the keys and values.

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
mapIterable.forEachRight((value) => console.log(key, value));
// will log to the console:
// 3 value3
// 2 value2
// 1 value1
// Ordering is deterministic on paper, but from a usability point of view effectively random
// as it is ordered by a mix of the hash of the key, and order of insertion.
```

Returns **[HashMap](#hashmap)** the hashmap you are foreaching on..

#### every

*   **See**: [Array.every](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every)

Test to see if ALL elements pass the test implemented by the passed <code>MatchesPredicate</code>.

*   if any element does not match, returns false
*   if all elements match, returns true.
*   if no elements match, returns false.
*   if the iterable is empty, returns true. (irrespective of the predicate)
*   if no predicate is provided, returns true.

##### Parameters

*   `everyPredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** if the provided function returns <code>false</code>, at any point the <code>every()</code> function returns false. (optional, default `(value,key,iterable)=>true`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>everyPredicate</code> (optional, default `undefined`)
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<reverse>?** a set of optional overrides to allow a user to define whether to search in reverse (optional, default `undefined`)

##### Examples

Do all values start with value. (yes)

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const everyResult = hashmap.every((value) => value.startsWith('value'));
// everyResult === true
```

Do all values start with value. (no)

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'doesntStart'],[3,'value3']]);
const everyResult = hashmap.every((value) => value.startsWith('value'));
// everyResult === false
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** true if all elements match, false if one or more elements fails to match.

#### some

*   **See**: [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)

Test to see if ANY element pass the test implemented by the passed <code>MatchesPredicate</code>.

*   if any element matches, returns true.
*   if all elements match returns true.
*   if no elements match returns false.
*   if the iterable is empty, returns true.
*   if no predicate is provided, returns true.

##### Parameters

*   `somePredicate` **[HashMap#MatchesPredicate](#hashmapmatchespredicate)** the predicate to identify if we have a match. (optional, default `(value,key,iterable)=>true`)
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>somePredicate</code> (optional, default `undefined`)
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<reverse>?** a set of optional overrides to allow a user to define whether to search in reverse (optional, default `undefined`)

##### Examples

Do any values start with value. (yes all of them)

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const someResult = hashmap.some((value) => value.startsWith('value'));
// someResult === true
```

Do any values start with value. (yes 2 of them)

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'doesntStart'],[3,'value3']]);
const someResult = hashmap.some((value) => value.startsWith('value'));
// someResult === true
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** true if all elements match, false if one or more elements fails to match.

#### reduce

*   **See**: [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
    if initial value is <code>undefined</code> or <code>null</code>, unlike Array.reduce,
    no error occurs, and it is simply passed as the accumulator value

Iterate through the map reducing it to a single value.

##### Parameters

*   `reduceFunction` **[HashMap#ReduceFunction](#hashmapreducefunction)** the predicate to identify if we have a match.
*   `initialValue` **any?** the initial value to start on the reduce.
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>reduceFunction</code>

##### Examples

add all the keys

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const reduceResult = hashmap.reduce((accumulator, value, key) => accumulator+key, 0);
// reduceResult === 6
```

add all the values into one string in reverse order

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const reduceResult = hashmap.reduce((accumulator, value) => value+accumulator, '');
// reduceResult === 'value3value2value1'
```

Returns **any** the final accumulated value.

#### reduceRight

*   **See**: [Array.reduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)
    if initial value is <code>undefined</code> or <code>null</code>, unlike Array.reduceRight,
    no error occurs, and it is simply passed as the accumulator value

Iterate backwards through the map reducing it to a single value.

##### Parameters

*   `reduceFunction` **[HashMap#ReduceFunction](#hashmapreducefunction)** the predicate to identify if we have a match.
*   `initialValue` **any?** the initial value to start on the reduce.
*   `thisArg` **any?** Value to use as <code>this</code> when executing <code>reduceFunction</code>

##### Examples

add all the keys

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const reduceResult = hashmap.reduceRight((accumulator, value, key) => accumulator+key, 0);
// reduceResult === 6
```

add all the values into one string in reverse order

```javascript
const hashmap = new HashMap([[1,'value1'],[2,'value2'],[3,'value3']]);
const reduceResult = hashmap.reduceRight((accumulator, value) => value+accumulator, '');
// reduceResult === 'value1value2value3'
```

Returns **any** the final accumulated value.

#### iterator

Iterates over all the entries in the map.

#### entries

Iterates over all the entries in the map.

#### entriesRight

Iterates over all the entries in the map.

#### keys

Iterates over all the keys in the map.

#### values

Iterates over all the values in the map.

#### keysRight

Iterates over all the keys in the map in reverse.

#### valuesRight

Iterates over all the values in the map in reverse.

### LinkedHashMap

**Extends HashMap**

HashMap - LinkedHashMap Implementation for JavaScript

#### Parameters

*   `copy` **([Map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map) | [HashMap](#hashmap) | [LinkedHashMap](#linkedhashmap) | Iterable<[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)\<key, value>> | [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object))?** 

**Meta**

*   **copyright**: Jack Moxley <https://github.com/jackmoxley>
*   **author**: Jack Moxley

#### clear

Returns **[HashMap](#hashmap)** 

#### setLeft

##### Parameters

*   `key`  
*   `value`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **[LinkedHashMap](#linkedhashmap)** 

#### emplaceLeft

##### Parameters

*   `key`  
*   `handler`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **any** 

#### push

##### Parameters

*   `key`  
*   `value`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **[LinkedHashMap](#linkedhashmap)** 

#### pushEmplace

##### Parameters

*   `key`  
*   `handler`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **any** 

#### unshift

##### Parameters

*   `key`  
*   `value`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **[LinkedHashMap](#linkedhashmap)** 

#### unshiftEmplace

##### Parameters

*   `key`  
*   `handler`  
*   `overrides` **[HashMap#overrides](#hashmapoverrides)\<equals, [hash](#hash)>?** a set of optional overrides to allow a user to define the hashcode and equals methods, rather than them being looked up.     \* @return {HashMap}

Returns **any** 

#### shift

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### pop

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### head

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### tail

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### optionalHead

Returns **[Option](#option)** 

#### optionalTail

Returns **[Option](#option)** 

#### headKey

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### tailKey

Returns **([undefined](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/undefined) | any)** 

#### optionalHeadKey

Returns **[Option](#option)** 

#### optionalTailKey

Returns **[Option](#option)** 

#### reverse

Returns **[LinkedHashMap](#linkedhashmap)** 

#### clone

Makes a copy of this LinkedHashMap

Returns **[LinkedHashMap](#linkedhashmap)** 

#### iterator

Iterates over all the entries in the map.

#### entries

Iterates over all the entries in the map.

#### entriesRight

Iterates over all the entries in the map in reverse order.

#### keys

Iterates over all the keys in the map.

#### values

Iterates over all the values in the map.

#### keysRight

Iterates over all the keys in the map in reverse.

#### valuesRight

Iterates over all the values in the map in reverse.

### Option

Option - a class to get round nullable fields.

#### Parameters

*   `has`  whether it contains a value or not.
*   `value`  the value to set

#### Examples

iterating over some

```javascript
const opt = Option.some("hello");
for (value of opt) {
   // loops once.
   console.log(opt);
}
console.log("world");
// logs - hello\nworld
```

iterating over none

```javascript
const opt = Option.none;
for (value of opt) {
  // does not loop.
   console.log(opt);
}
console.log("world");
// logs - world
```

**Meta**

*   **copyright**: Jack Moxley <https://github.com/jackmoxley>
*   **author**: Jack Moxley

#### size

Return the size of this option.

*   1 if it has a value
*   0 if it doesn't

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** 

#### iterator

Provides an iterable for the Option
If using a for loop.

*   If it has a value the loop will execute just once.
*   If it doesn't have a value the loop will not execute

##### Examples

iterating over some

```javascript
const opt = Option.some("hello");
for (value of opt) {
   // loops once.
   console.log(opt);
}
console.log("world");
// logs - hello\nworld
```

iterating over none

```javascript
const opt = Option.none;
for (value of opt) {
  // does not loop.
   console.log(opt);
}
console.log("world");
// logs - world
```

Returns **Generator\<any, void, any>** 

#### none

A constant representation of an Option with nothing in it: <code>{value:undefined,has:false}</code>

Type: [Option](#option)

##### Examples

create an option using none

```javascript
const option = Option.none;
// option.has === false
// option.value === undefined
// option.size === 0
```

#### some

When called with a value returns an Option object of the form: <code>{value:value,has:true}</code>
Even if a value is not provided it still counts as existing, this is different from other libraries,
we are effectively saying, null and undefined count as valid values.

##### Parameters

*   `value`  the value

##### Examples

create an option using some

```javascript
const myValue = 'hello';
const option = Option.some(myValue);
// option.has === true
// option.value === 'hello'
// option.size === 1
```

Returns **[Option](#option)** the option in the form <code>{value:value,has:true}</code>

### HashMap#overrideEquals

User Defined Equals Method
A user defined function to define an equals method against 2 keys.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `firstKey` **any** the first key.
*   `secondKey` **any** the second key

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** is it equal or not

### HashMap#overrideHash

User Defined Hash Method
A user defined function to describe how to hash a key.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `key` **any** the first key.

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** a 32 bit integer as a hash.

### HashMap#overrides

User defined hashing and equals methods
HashMap will find the best fit for your objects, and if your keys themselves have the appropriate methods,
then it will use them. However if you want to override that functionality this object allows you to do it.
Not all functions and properties are used in every function, please refer to that function for details.
If a function in future chooses to use one of the other properties or functions, it will NOT be marked as a breaking change.
So be explicit.

Type: [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)

#### Properties

*   `hash` **([number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number) | [HashMap#overrideHash](#hashmapoverridehash))?** The overriding hash value, or method to use.
*   `equals` **[HashMap#overrideEquals](#hashmapoverrideequals)?** The overriding equals method to use
*   `reverse` **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** whether to search in reverse.

### HashMap#emplaceUpdate

Emplace Update Method
A user defined method to describe how to update our map.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `oldValue` **any** the oldValue to update.
*   `key` **any** the key to the entry.
*   `map` **[HashMap](#hashmap)** the hashmap.

Returns **any** the new value to update the map with.

### HashMap#emplaceInsert

Emplace Insert Method
A user defined method to describe how to insert into our map.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `key` **any** the key to the entry.
*   `map` **[HashMap](#hashmap)** the hashmap.

Returns **any** the new value we want to insert.

### HashMap#emplaceHandler

Emplace handler methods

*   Let M be this hashmap.
*   For each Record { \[\[Key]], \[\[Value]] } e that is an element of entries, do
*   If Equal(e.\[\[Key]], key) is true, then
*   If HasProperty(handler, "update") is true, then
    *   Let updateFn be ? Get(handler, "update").
    *   Let updated be ? Call(updateFn, handler,  e.\[\[Value]], key, M ).
    *   Set e.\[\[Value]] to updated.
*   Return e.\[\[Value]].
*   Let insertFn be ? Get(handler, "insert").
*   Let inserted be ? Call(insertFn, handler,  e.\[\[Value]], key, M ).
*   Set e.\[\[Value]] to inserted.
*   Return e.\[\[Value]].

Type: [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)

#### Properties

*   `update` **[HashMap#emplaceUpdate](#hashmapemplaceupdate)?** The update method to use.
*   `insert` **[HashMap#emplaceInsert](#hashmapemplaceinsert)?** The insert method to use

### HashMap#ForEachCallback

For Each Function
A callback to execute on every <code>\[key,value]</code> pair of this map iterable.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `value` **any?** the entry value.
*   `key` **any?** the entry key
*   `map` **[HashMap](#hashmap)?** the calling Map Iterable.

#### Examples

log the keys and values

```javascript
const forEachFunction = (value, key) => console.log(key,value)
```

### HashMap#MatchesPredicate

Test each element of the map to see if it matches and return

*   true if the key and value match.
*   false if it doesn't.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `value` **any?** the entry value.
*   `key` **any?** the entry key
*   `iterable` **[HashMap](#hashmap)?** the HashMap.

#### Examples

Only match keys divisible by 2

```javascript
const myMatchPredicate = (value, key) => key % 2 === 0;
```

Only match values which are equal to another key in the map

```javascript
const myMatchPredicate = (value, key, mapIterable) => mapIterable.has(value);
```

An alternative implementation, (but potentially slower, and assumes no undefined value)

```javascript
const myMatchPredicate = (value, key, mapIterable) => mapIterable.indexOf(key) !== undefined;
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** a value that coerces to true if it matches, or to false otherwise.

### HashMap#ReduceFunction

*   **See**: [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

Reduce Function
A callback to accumulate values from the HashMap <code>\[key,value]</code> into a single value.

Type: [Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)

#### Parameters

*   `accumulator` **any?** the value from the last execution of this function.
*   `value` **any?** the entry value.
*   `key` **any?** the entry key
*   `hashmap` **[HashMap](#hashmap)?** the calling HashMap.

#### Examples

add all the keys

```javascript
const reduceFunction = (accumulator, value, key) => accumulator+key
```

Returns **any** \[accumulator] - the value to pass to the next time this function is called or the final return value.

### isFunction

Is the passed value not null and a function

#### Parameters

*   `func` **([function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function) | any)** the function/object to test

#### Examples

test if its a function

```javascript
const myFunc = () => 1 + 1;
Mootable.isFunction(myFunc) === true;
```

test if its not a function

```javascript
const notAFunction = {};
Mootable.isFunction(notAFunction) === false;
```

test if its null

```javascript
const notAFunction = null;
Mootable.isFunction(notAFunction) === false;
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** true if this is function and not null.

### isIterable

Is the passed object iterable and not null, i.e. it has a function that has a type of
\[Symbol.iterator]

#### Parameters

*   `iterable` **(Iterable | any)** the object to test

#### Examples

test if its iterable

```javascript
class MyIterable {
    * [Symbol.iterator]() {
        yield 1;
    }
}
Mootable.isIterable(new MyIterable()) === true;
```

test if its not an iterable

```javascript
const notAnIterable = {};
Mootable.isIterable(notAnIterable) === false;
```

test if its null

```javascript
const notAnIterable = null;
Mootable.isIterable(notAnIterable) === false;
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** true if this has a Symbol.iterator function

### isString

Is the passed value is not null and is a string

#### Parameters

*   `str` **([string](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String) | any)** the string/object to test

#### Examples

test if its iterable

```javascript
const myString = "hello world";
Mootable.isString(myString) === true;
```

test if its not an iterable

```javascript
const notAString = {};
Mootable.isString(notAString) === false;
```

test if its null

```javascript
const notAString = null;
Mootable.isString(notAString) === false;
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** true if this is a string

### sameValue

*   **See**: [sameValue](https://262.ecma-international.org/6.0/#sec-samevalue)

sameValue is the result of Object.is.
The only difference between sameValue and sameValueZero is that +0 and -0 are considered different with sameValue.

#### Parameters

*   `x`  the first object to compare
*   `y`  the second object to compare

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** if they are equals according to [ECMA Spec for Same Value](https://262.ecma-international.org/6.0/#sec-samevalue)

### sameValueZero

*   **See**: [saveValueZero](https://262.ecma-international.org/6.0/#sec-samevaluezero)

sameValueZero is the equality method used by Map, Array, Set etc.
The only difference between === and sameValueZero is that NaN counts as equal on sameValueZero

#### Parameters

*   `x`  the first object to compare
*   `y`  the second object to compare

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** if they are equals according to [ECMA Spec for Same Value Zero](https://262.ecma-international.org/6.0/#sec-samevaluezero)

### abstractEquals

*   **See**: [abstractEquals](https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison)

The abstract Equals method <code>==</code>.
Simply does an abstract equality comparison <code>==</code> against 2 values

#### Parameters

*   `x`  the first object to compare
*   `y`  the second object to compare

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** if they are equals according to [ECMA Spec for Abstract Equality](https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison)

### strictEquals

*   **See**: [strictEquals](https://262.ecma-international.org/6.0/#sec-strict-equality-comparison)

The strict Equals method <code>===</code>.
Simply does a strict equality comparison <code>===</code> against 2 values

#### Parameters

*   `x`  the first object to compare
*   `y`  the second object to compare

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** if they are equals according to [ECMA Spec for Strict Equality](https://262.ecma-international.org/6.0/#sec-strict-equality-comparison)

### hammingWeight

*   **See**: [hammingWeight](https://en.wikipedia.org/wiki/Hamming_weight)

Counts the number of ones in a binary representation of a 32 bit integer.

#### Parameters

*   `flags` **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** 32 bit integer

#### Examples

count the number of bits set to one for the value 22

```javascript
const myNumber = 22; // 10110 in binary
Mootable.hammingWeight(myNumber) === 3;
```

count the number of bits set to one for the value 12947

```javascript
const myNumber = 12947; // 11001010010011 in binary
Mootable.hammingWeight(myNumber) === 7;
```

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** amount of ones.

### hash

*   **See**: [MurmurHash specification on Github](https://github.com/aappleby/smhasher)
*   **See**: [MurmurHash on Wikipedia](https://en.wikipedia.org/wiki/MurmurHash)

Modified Murmur3 hash generator, with capped lengths.
This is NOT a cryptographic hash, this hash is designed to create as even a spread across a 32bit integer as is possible.

#### Parameters

*   `key`  the string being hashed
*   `len`  the max limit on the number of characters to hash (optional, default `0`)
*   `seed`  an optional random seed, or previous hash value to continue hashing against. (optional, default `0`)

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** the hash

### hashCodeFor

Given any object return back a hashcode

*   If the key is undefined, null, false, NaN, infinite etc then it will be assigned a hash of 0.
*   If it is a primitive such as string, number bigint it either take the numeric value, or the string value, and hash that.
*   if it is a function, symbol or regex it hashes their string values.
*   if it is a date, it uses the time value as the hash.

Otherwise

*   If it has a hashCode function it will execute it, passing the key as the first and only argument. It will call this function again on its result.
*   If it has a hashCode attribute it will call this function on it.
*   If it can't do any of the above, it will assign a randomly generated hashcode, to the key using a hidden property.

As with all hashmaps, there is a contractual equivalence between hashcode and equals methods,
in that any object that equals another, should produce the same hashcode.

#### Parameters

*   `key` **any** the key to get the hash code from

Returns **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** the hash code.

### equalsFor

Given a key, produce an equals method that fits the hashcode contract.

*   In almost all cases it will return with ECMASpec sameValueZero method. As is the case with native map, set and array.
*   If it is a regex, it compares the type, and the string values.
*   If it is a date, it compares the type, and the time values.
*   If it is an option, it compares if they both have values, and then the values.
*   If it has an equals function and that equals function when comapring 2 keys, return true. then it will use that.
    *   The function can either be in the form <code>key.equals(other)</code>, or <code>key.equals(other,key)</code> in the case of static-like functions.

The expectation and requirement is this key will always be the first argument to the method, the behaviour maybe unexpected if parameters are reversed.

As with all hashmaps, there is a contractual equivalence between hashcode and equals methods,
in that any object that equals another, should produce the same hashcode.

#### Parameters

*   `key` **any** the key to get the hash code from

Returns **(function (any, any): [boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean))** an equals function for 2 keys.

### equalsAndHash

Given any object return back a hashcode

*   If the key is undefined, null, false, NaN, infinite etc then it will be assigned a hash of 0.
*   If it is a primitive such as string, number bigint it either take the numeric value, or the string value, and hash that.
*   if it is a function, symbol or regex it hashes their string values.
*   if it is a date, it uses the time value as the hash.

Otherwise

*   If it has a hashCode function it will execute it, passing the key as the first and only argument. It will call this function again on its result.
*   If it has a hashCode attribute it will call this function on it.
*   If it can't do any of the above, it will assign a randomly generated hashcode, to the key using a hidden property.

As with all hashmaps, there is a contractual equivalence between hashcode and equals methods,
in that any object that equals another, should produce the same hashcode.

#### Parameters

*   `key` **any** the key to get the hash code from
*   `options`  

Returns **{hash: [number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number), equals: [function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)}** the hash code and equals function.

### some

A function that when called with a value returns an Option object of the form: <code>{value:value,has:true}</code>
Even if a value is not provided it still counts as existing, this is different from other libraries,
we are effectively saying that null and undefined count as valid values.

Type: function (any?): [Option](#option)

#### Parameters

*   `value`  

#### Examples

create an option using some

```javascript
const myValue = 'hello';
const option = some(myValue);
// option.has === true
// option.value === 'hello'
// option.size === 1
```

### none

A constant representation of an Option with nothing in it: <code>{value:undefined,has:false}</code>

Type: [Option](#option)

#### Examples

create an option using none

```javascript
const option = none;
// option.has === false
// option.value === undefined
// option.size === 0
```

## Benchmarks

*   Current Benchmarks can be found under benchmark_results.
    *   The default benchmark does a single set, get and delete against a hashmap of a specific size. It does this thousands of times, and finds an approximate average.
    *   If you would like me to include your library for benchmarking, raise an issue in github.
        *   It must be in NPM
        *   It must have an identical interface to JS Map
        *   It must be fully written in JS. (Transpiling is acceptable) So that we can guarantee it works in the browser, not just node.

### Benchmarks on version 1.0.2

![Set Get And Delete](BenchmarkSGD.png)

## Background

*   This repository is a reimplemented version of the [npm hashmap](https://npmjs.org/package/hashmap) repository. It takes that implementation as a starting point, and moves it closer to the core functionality hashmaps are designed to achieve.
*   The tests have remained mostly the same, as has some documentation, everything else has changed. The interfaces have now diverged.

## LICENSE

The MIT License (MIT)

Copyright (c) 2021 Jack Moxley

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF
